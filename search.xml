<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[信用评分]]></title>
    <url>%2F2018%2F10%2F24%2F%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[信用评分指帮助贷款机构发放消费信贷的一整套决策模型及其支持技术。一般地，信用评分技术将客户分为好客户与坏客户两类，比如说，好客户(good)能够按期还本付息（履约），违约的就是坏客户(bad)。具体做法是根据历史上每个类别（履约、违约）的若干样本，从已知的数据中考察借款人的哪些特征对其拖欠或违约行为有影响，从而测量借款人的违约风险，为信贷决策提供依据。Logistic回归是信用评分领域运用最成熟最广泛的统计技术。]]></content>
  </entry>
  <entry>
    <title><![CDATA[简历]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[#iOS/python 数据分析师 张珈盛 - 26岁 现居住地：深圳 Github —&gt;&gt; jasonmes.github.io 技术博客网站 —&gt;&gt; jasonmes.github.io 计算机专业两年工作经验，之前从事的是Apple iOS开发 以下的内容大部分做了超链接，点击之后都将会转到我的技术博客展示页面 专业技能 精通SQL. 1 2 精通用Python做数据处理 numpy pandas matplotlib seaborn 懂sklearn算法 无监督学习 随机森林 决策树 线性回归 监督学习 knn em 呼呼 扎实的统计学知识 会excel 数据透视表 vlookup 常用函数的使用 基础图表的制作 会Matlab 灵活使用爬虫 工作经历项目一 例如 ：商品点击预测项目： 利用pyspark读取、合并超过100GB的商品以及用户点击数据，并且进行数据清洗，如剔除异常数据点 根据word2vec模型提取商品中的文本信息，构建词向量特征；使用SMOTE解决非平衡数据的问题 使用python训练xgboost+lr分类模型，并通过交叉验证对模型进行调参优化 根据线上AB Test的结果，新模型的roc auc比原模型提高了10%，logloss减小了10% 项目二 例如： 想了解更多—&gt;&gt;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[交易数据异常处理]]></title>
    <url>%2F2017%2F01%2F24%2F%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python实现逻辑回归与梯度下降策略]]></title>
    <url>%2F2017%2F01%2F21%2FPython%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[浅谈《线性回归》 与 《逻辑回归》线性回归 在线性回归的算法推导中，根据得到的模型与真实数据之间存在的偏差，我们称为误差值。 似然函数 对数变换后，越大越好，越接近目标值 该函数由乘法将为加减之后得到最小二乘法，也叫目标函数 对目标函数求偏导 我们给一堆数据给机器，告诉他以目标函数为标准来预测结果，但是目标函数不能直接求解 我们引入梯度下降策略 有三种方法 批量梯度下降：慢，但是可以得到最优解 小批量梯度下降：最实用，且快 随机梯度下降：快，但是不一定会朝着收敛的方向 学习率：会对结果产生巨大的影响，一般选择小一些，迭代会慢一些 我们认为这个误差值，必定是独立并且具有相同分布，服从均值为0，方差 $\theta_2$ 的高斯分布 独立和同分布将是我们后面数据分析经常遇到的特点 使用的评估方法：评估项\mathbb{R}，1减去残差平方和和类似方差值，其中残差平方和指的是 预测值和真实值之间的差异 残差平方和的值越小，R方越接近1，则说明你的模型越好 逻辑回归 最牛逼的二分类算法：边策的边界可以是 —》非线性的 sigmoid函数，自变量的取值为任意实数的值域为[0, 1]. 我们在线性回归中可以得到一个预测值，再将该值映射到sigmoid函数中，这样就完成了由值到概率的转换，也就是分类任务顺便提一下混淆矩阵：Confusion matrix大部分博客都把问题说的晦涩难懂。其实可以这样理解，例如本来要预测为good–&gt;T的数据，被预测为bad–&gt;F；要预测为bad–T的数据被预测为good–F，于是混淆矩阵就是把预测正确和错误的四个结果用一个表来表示出来。T + T = （2T + 2F）什么过采样，或者说什么是上采样？就是利用SMOTE算法，选择采样少的数据，用欧式距离计算出每个点的距离，以此来计算出k近邻值，然后在k近邻值附近随机散落达到的点的集合，就可以向上增加采到数量相似的样本。 什么欧式距离？是一个通常采用的距离定义，它是在m维空间中两个点之间的真实距离。在二维和三维空间中的欧氏距离的就是两点之间的距离]]></content>
  </entry>
  <entry>
    <title><![CDATA[One Hot Encoding in Scikit-Learn]]></title>
    <url>%2F2016%2F10%2F18%2FOne-Hot-Encoding-in-Scikit-Learn%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[内地城市素质排行]]></title>
    <url>%2F2016%2F07%2F20%2F%E5%86%85%E5%9C%B0%E5%9F%8E%E5%B8%82%E7%B4%A0%E8%B4%A8%E6%8E%92%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[泰坦尼克号生存预测]]></title>
    <url>%2F2016%2F05%2F08%2F%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%94%9F%E5%AD%98%E9%A2%84%E6%B5%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[柯基犬]]></title>
    <url>%2F2016%2F05%2F01%2F%E6%9F%AF%E5%9F%BA%E7%8A%AC%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python---控制台输出空心菱形]]></title>
    <url>%2F2016%2F04%2F25%2FPython---%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%EF%BC%9A%E7%A9%BA%E5%BF%83%E8%8F%B1%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[我这次分成了四个部分 其实第一部分和最后一部分是一样的 关键在第二部分和第三部分，这两部分是几乎一样的。 1.第一部分和最后一部分是一样的，就是判断中间的位置打印*，其他位置打印空格 123456for i in range(1, 20): if i == 10: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 2.第二部分和第三部分 其实和打印三角形是一样，第三部分无非就是倒着打印，记住，这里的j循环，不仅仅是控制行数，同时也是用来找到每行打印*的位置 如果有不明白的请回头好好理解打印空心三角形，我上一片博客 1234567891011121314151617181920# 第二部分for j in range(9, 4, -1): for i in range(1, 20): if i == j: print(&quot;*&quot;, end=&quot;&quot;) elif i == 20 - j: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;)# 第三部分for j in range(4, 10): for i in range(1, 20): if i == j: print(&quot;*&quot;, end=&quot;&quot;) elif i == 20 - j: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python---控制台输出：空心正方形]]></title>
    <url>%2F2016%2F04%2F22%2FPython---%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%EF%BC%8C%E7%A9%BA%E5%BF%83%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[实心的都会写，直接循环print，那么空心的呢？ 代码是这样的1234567891011121314151617181920212223# 打印正方形for i in range(20): if i % 2 == 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;)print()for j in range(8): for i in range(20): if i == 0: print(&quot;*&quot;, end=&quot;&quot;) elif i == 18: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;)for i in range(20): if i % 2 == 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;) 是的分成了三个部分，为了方便理解我分成了三个部分 第一部分和第三部分其实就是打印第一行和最后一行，最简单，这里打印10个*，为了好看，增加了空格隔开，所以range是20 12345678for i in range(20): # 以空格隔开，刚好打印*的位置是i偶数的位置，i奇数的位置打印空格 if i % 2 == 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;)# 要记得加入这句话，换行，上面的代码运行完毕不会换行print() 第二部分，最关键这里： j循环控制行数，i循环控制每行在哪个位置打印，所以i等于0或者18的时候打印，i等于18的时候打印*之后就要break本次循环进入外层的j循环 end的使用：end=“”的时候，就是不换行，也不空格。最关键的一个代码。 123456789for j in range(8): for i in range(20): if i == 0: print(&quot;*&quot;, end=&quot;&quot;) elif i == 18: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 最后一部分和第一部分是一样的，代码照搬空心正方形理解透彻以后我们进入下一个篇章，打印空心三角形]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python---控制台输出：空心三角形]]></title>
    <url>%2F2016%2F04%2F20%2FPython---%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%EF%BC%9A%E7%A9%BA%E5%BF%83%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[是的我还是分成了三个部分 第一部分和最后一部分都是很容易的，如果理解了空心正方形的话 这里依然选择长度是20的三角形 为了好看，依然用空格隔开，也增加了难度 第一部分1234567# 在中间打印的*，判断i循环下，i累加到10的时候，就打印*，其他时候打印空格加end不换行for i in range(1, 20): if i == 10: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 第二部分123456789101112# j循环控制行数且控制每行第一个*打印在什么地方，第二行i==9，第三行i==8，第四行i==7，所以使用j递减循环，i循环每行在哪个位置打印*或者空格。for j in range(9, 1, -1): for i in range(1, 20): if i == j: print(&quot;*&quot;, end=&quot;&quot;) # 为什么判断是20-j，因为当i==j的时候，打印的*是这行打印的第一个*，每行长度是20，最后一个*的位置肯定在20-j的位置，为了对称。 elif i == 20 - j: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 第三部分 123456# 和打印正方形的原理是一样，判断哪个位置打印*，这里不同，为了好看，要灵活判断打印*的位置，这里i是奇数的时候打印*，是偶数时候是打印*空格for i in range(1, 20): if i % 2 != 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;)]]></content>
  </entry>
</search>
