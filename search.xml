<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[超链接简历]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Python AI分析师张珈盛 - 26岁 现居住地：深圳 技术博客网站 —&gt;&gt; jasonmes.github.io 计算机专业两年工作经验，之前从事的是Apple iOS开发以及BI工程师 以下的内容大部分做了超链接，点击之后都将会转到我的技术博客展示页面 专业技能 熟练使用NOSQL和SQL. 熟练使用以下四大框架做数据可视化处理，阅读过官方文档 numpy—pandas–matplotlib–seaborn 灵活对数据进行可视化，有较多经验，例如使用比Exel更专业的软件Tableau Prep将数据进行清洗，转换，集成，处理 也使用过百度最新的天工物联网平台AloT Plarfrom进行快速数据可视化 也会使用Tensorboard对创建的神经网络模型进行可视化 灵活的运用numpy手写数学公式，对机器学习背后的数学原理有了解 灵活的使用数据挖掘十大算法例如(ID3)C4.5，Adaboost，EM, PageRank等 协助过伙伴参与过Kaggle和天池等专业平台的数据大竞赛，使用的算法有Xgboost，以及以下算法 无监督学习(Unsupervised) 聚类与降维：SVD—PCA—Kmeans 关联分析：Apriori—FP_Growth—隐马尔科夫模型 监督学习(Supervised) 回归：线性回归—-多项式回归—-决策树—RF 分类：k近邻—逻辑回归—朴素贝叶斯—SVM 灵活使用人工神经网络ANN，卷积神经网络CNN，循环神经网络RNN和对图像等进行分析和分类 熟悉神经网络背后的原理和反向传播算法BP算法和Softmax，灵活使用dropout算法等解决神经网络出现过拟合的问题。 使用参数共享原则解决全链接卷积神经网络下带来的可怕的算力飙升问题等等 当然也会使用以下几大框架进行工作例如Tensorflow，Caffe，MxNet，Pytorch 工作经历项目一 ：人脸检测： 对数据的获取，对数据进行一个随机的裁剪 制作LMDB数据源 训练ALEXNET网络 多尺度的人脸检测：采取级联的网络，再加上矫正网络来解决检测速度过慢的问题 项目二 ： 商品点击预测项目 利用pyspark读取、合并超过100GB的商品以及用户点击数据，并且进行数据清洗，如剔除异常数据点 根据word2vec模型提取商品中的文本信息，构建词向量特征；使用SMOTE解决非平衡数据的问题 使用python训练xgboost分类模型，并通过交叉验证对模型进行调参优化 根据线上AB Test的结果，新模型的roc auc比原模型提高了10%，logloss减小了10% 加我微信详聊吧，我电话13232182628，邮箱：wow336@163.com我超爱柯基犬的 扫码加我]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2018%2F10%2F29%2FSQL%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[学会使用graphviz]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8graphviz%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[信用评分]]></title>
    <url>%2F2018%2F10%2F24%2F%E4%BF%A1%E7%94%A8%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[信用评分指帮助贷款机构发放消费信贷的一整套决策模型及其支持技术。一般地，信用评分技术将客户分为好客户与坏客户两类，比如说，好客户(good)能够按期还本付息（履约），违约的就是坏客户(bad)。具体做法是根据历史上每个类别（履约、违约）的若干样本，从已知的数据中考察借款人的哪些特征对其拖欠或违约行为有影响，从而测量借款人的违约风险，为信贷决策提供依据。Logistic回归是信用评分领域运用最成熟最广泛的统计技术。]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中使用Tableau Desktop方法总结]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%BF%E7%94%A8Tableau-Desktop%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[范畴 BI工程师：Business Intelligence Tableau工程师 报表开发工程师 主要工作：采购、存储、分类、清洗、加工 ———–人是视觉动物，要用数据把一个故事讲活，图表是必不可少的。 如果你经常看到做数据分析同事，在SQL客户端里执行完查询，把结果复制/粘贴到Excel里再做成图表，那说明你的公司缺少一个可靠的数据可视化平台。 1.0 首先推荐的官方培训视频http://www.tableau.com/zh-cn/learn/training. 你可以学到的东西 工具界面操作 文件的发布和共享 连接数据库、连接文本数据、发布数据源、数据提取、数据关联等 分组、集、数据桶、参数、排序、参考线、趋势线、筛选器、预测等 创建仪表板和故事 一般常用图形绘制及地图绘制 计算字段以及LOD表达式（“超越视图级别” 详细级别表达式） 格式调整与布局 官方网站截图 2.0 官网进阶视频，注册就可以看，还附带高清视频和使用的数据包下载http://www.tableau.com/zh-cn/learn/webinars. 所见即所得，高效创建Tableau工作簿 Tableau的高级分析应用 数据可视化提升网络营销洞察力 如何使用 Tableau 超越 Excel 销售分析的力量 可视化分析最佳实践 Tableau 与 R : 数据统计分析的完美集成 进阶官方视频]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中，遇到的问题总结--量化交易]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%EF%BC%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[手写简单三层神经网络，激活函数为sigmoid]]></title>
    <url>%2F2017%2F11%2F24%2F%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E4%B8%89%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E4%B8%BAsigmoid%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac下安装xgboost不成功的原因]]></title>
    <url>%2F2017%2F11%2F17%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85xgboost%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[第一步今天我发现git命令无法执行，homebrew也无法使用，这种情景我在升级OS X El Capitan也遇到过一次，完整异常提示如下： invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决方法 解决方法很简单，就是在命令行中执行‘’’xcode-select –install‘’’ 然后会启动下载并安装Command line tools OS X 10.11) for Xcode 注意，这个命令并不会下载完整的Xcode，但是下载依然会很慢，如果你有苹果开发者账号的话，你可以去http://developer.apple.com/downloads下载 Command line tools OS X 10.1x来安装。 第二步pip install xgboost]]></content>
  </entry>
  <entry>
    <title><![CDATA[‘经常用到的数学公式整理’’]]></title>
    <url>%2F2017%2F11%2F11%2F%E2%80%98%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86%E2%80%99%E2%80%99%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[如果计算能力足够强大，是不是就不需要对数据降维]]></title>
    <url>%2F2017%2F11%2F07%2F%E5%A6%82%E6%9E%9C%E8%AE%A1%E7%AE%97%E8%83%BD%E5%8A%9B%E8%B6%B3%E5%A4%9F%E5%BC%BA%E5%A4%A7%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B0%B1%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[降噪都有哪些方法]]></title>
    <url>%2F2017%2F11%2F07%2F%E9%99%8D%E5%99%AA%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[NOSQL和SQL]]></title>
    <url>%2F2017%2F11%2F03%2FNOSQL%E5%92%8CSQL%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[十大机器学习算法]]></title>
    <url>%2F2017%2F10%2F27%2F%E5%8D%81%E5%A4%A7%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[十大经典数据挖掘算法]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[k临近值 决策树 随机森林 朴素贝叶斯]]></title>
    <url>%2F2017%2F06%2F24%2Fk%E4%B8%B4%E8%BF%91%E5%80%BC-%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[xgboots 初体验]]></title>
    <url>%2F2017%2F05%2F17%2Fxgboots-%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何快速将数据导入MySQL]]></title>
    <url>%2F2017%2F04%2F17%2F%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5MySQL%2F</url>
    <content type="text"><![CDATA[无论是刚刚入行的萌新，还是已经驰骋数据圈的数据猿，前期的数据准备工作都需要足够的娴熟和准确]]></content>
  </entry>
  <entry>
    <title><![CDATA[缺失值处理方法总结]]></title>
    <url>%2F2017%2F03%2F29%2F%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[PCA 与 DCA]]></title>
    <url>%2F2017%2F03%2F20%2FPCA-%E4%B8%8E-DCA%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据拟合和常见的聚类算法]]></title>
    <url>%2F2017%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88%E5%92%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[‘DBSCAN-or-K_Means’]]></title>
    <url>%2F2017%2F03%2F10%2F%E2%80%98DBSCAN-or-K-Means%E2%80%99%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[SVM-Support_Vector_Machine]]></title>
    <url>%2F2017%2F03%2F07%2FSVM-Support-Vector-Machine%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用贝叶斯分类新闻]]></title>
    <url>%2F2017%2F02%2F16%2F%E4%BD%BF%E7%94%A8%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E6%96%B0%E9%97%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯纠正单词拼写错误]]></title>
    <url>%2F2017%2F01%2F30%2F%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BA%A0%E6%AD%A3%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[交易数据异常处理]]></title>
    <url>%2F2017%2F01%2F24%2F%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python实现逻辑回归与梯度下降策略]]></title>
    <url>%2F2017%2F01%2F21%2FPython%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[浅谈《线性回归》 与 《逻辑回归》线性回归 在线性回归的算法推导中，根据得到的模型与真实数据之间存在的偏差，我们称为误差值。 似然函数 对数变换后，越大越好，越接近目标值 该函数由乘法将为加减之后得到最小二乘法，也叫目标函数 对目标函数求偏导 我们给一堆数据给机器，告诉他以目标函数为标准来预测结果，但是目标函数不能直接求解 我们引入梯度下降策略 有三种方法 批量梯度下降：慢，但是可以得到最优解 小批量梯度下降：最实用，且快 随机梯度下降：快，但是不一定会朝着收敛的方向 学习率：会对结果产生巨大的影响，一般选择小一些，迭代会慢一些 我们认为这个误差值，必定是独立并且具有相同分布，服从均值为0，方差 $\theta_2$ 的高斯分布 独立和同分布将是我们后面数据分析经常遇到的特点 使用的评估方法：评估项\mathbb{R}，1减去残差平方和和类似方差值，其中残差平方和指的是 预测值和真实值之间的差异 残差平方和的值越小，R方越接近1，则说明你的模型越好 逻辑回归 最牛逼的二分类算法：边策的边界可以是 —》非线性的 sigmoid函数，自变量的取值为任意实数的值域为[0, 1]. 我们在线性回归中可以得到一个预测值，再将该值映射到sigmoid函数中，这样就完成了由值到概率的转换，也就是分类任务顺便提一下混淆矩阵：Confusion matrix大部分博客都把问题说的晦涩难懂。其实可以这样理解，例如本来要预测为good–&gt;T的数据，被预测为bad–&gt;F；要预测为bad–T的数据被预测为good–F，于是混淆矩阵就是把预测正确和错误的四个结果用一个表来表示出来。T + T = （2T + 2F）什么过采样，或者说什么是上采样？就是利用SMOTE算法，选择采样少的数据，用欧式距离计算出每个点的距离，以此来计算出k近邻值，然后在k近邻值附近随机散落达到的点的集合，就可以向上增加采到数量相似的样本。 什么欧式距离？是一个通常采用的距离定义，它是在m维空间中两个点之间的真实距离。在二维和三维空间中的欧氏距离的就是两点之间的距离]]></content>
  </entry>
  <entry>
    <title><![CDATA[One Hot Encoding in Scikit-Learn]]></title>
    <url>%2F2016%2F10%2F18%2FOne-Hot-Encoding-in-Scikit-Learn%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[内地城市素质排行]]></title>
    <url>%2F2016%2F07%2F20%2F%E5%86%85%E5%9C%B0%E5%9F%8E%E5%B8%82%E7%B4%A0%E8%B4%A8%E6%8E%92%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[泰坦尼克号生存预测]]></title>
    <url>%2F2016%2F05%2F08%2F%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%94%9F%E5%AD%98%E9%A2%84%E6%B5%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[柯基犬]]></title>
    <url>%2F2016%2F05%2F01%2F%E6%9F%AF%E5%9F%BA%E7%8A%AC%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python---控制台输出空心菱形]]></title>
    <url>%2F2016%2F04%2F25%2FPython---%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%EF%BC%9A%E7%A9%BA%E5%BF%83%E8%8F%B1%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[我这次分成了四个部分 其实第一部分和最后一部分是一样的 关键在第二部分和第三部分，这两部分是几乎一样的。 1.第一部分和最后一部分是一样的，就是判断中间的位置打印*，其他位置打印空格 123456for i in range(1, 20): if i == 10: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 2.第二部分和第三部分 其实和打印三角形是一样，第三部分无非就是倒着打印，记住，这里的j循环，不仅仅是控制行数，同时也是用来找到每行打印*的位置 如果有不明白的请回头好好理解打印空心三角形，我上一片博客 1234567891011121314151617181920# 第二部分for j in range(9, 4, -1): for i in range(1, 20): if i == j: print(&quot;*&quot;, end=&quot;&quot;) elif i == 20 - j: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;)# 第三部分for j in range(4, 10): for i in range(1, 20): if i == j: print(&quot;*&quot;, end=&quot;&quot;) elif i == 20 - j: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python---控制台输出：空心正方形]]></title>
    <url>%2F2016%2F04%2F22%2FPython---%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%EF%BC%8C%E7%A9%BA%E5%BF%83%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[实心的都会写，直接循环print，那么空心的呢？ 代码是这样的1234567891011121314151617181920212223# 打印正方形for i in range(20): if i % 2 == 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;)print()for j in range(8): for i in range(20): if i == 0: print(&quot;*&quot;, end=&quot;&quot;) elif i == 18: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;)for i in range(20): if i % 2 == 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;) 是的分成了三个部分，为了方便理解我分成了三个部分 第一部分和第三部分其实就是打印第一行和最后一行，最简单，这里打印10个*，为了好看，增加了空格隔开，所以range是20 12345678for i in range(20): # 以空格隔开，刚好打印*的位置是i偶数的位置，i奇数的位置打印空格 if i % 2 == 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;)# 要记得加入这句话，换行，上面的代码运行完毕不会换行print() 第二部分，最关键这里： j循环控制行数，i循环控制每行在哪个位置打印，所以i等于0或者18的时候打印，i等于18的时候打印*之后就要break本次循环进入外层的j循环 end的使用：end=“”的时候，就是不换行，也不空格。最关键的一个代码。 123456789for j in range(8): for i in range(20): if i == 0: print(&quot;*&quot;, end=&quot;&quot;) elif i == 18: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 最后一部分和第一部分是一样的，代码照搬空心正方形理解透彻以后我们进入下一个篇章，打印空心三角形]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python---控制台输出：空心三角形]]></title>
    <url>%2F2016%2F04%2F20%2FPython---%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%EF%BC%9A%E7%A9%BA%E5%BF%83%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[是的我还是分成了三个部分 第一部分和最后一部分都是很容易的，如果理解了空心正方形的话 这里依然选择长度是20的三角形 为了好看，依然用空格隔开，也增加了难度 第一部分1234567# 在中间打印的*，判断i循环下，i累加到10的时候，就打印*，其他时候打印空格加end不换行for i in range(1, 20): if i == 10: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 第二部分123456789101112# j循环控制行数且控制每行第一个*打印在什么地方，第二行i==9，第三行i==8，第四行i==7，所以使用j递减循环，i循环每行在哪个位置打印*或者空格。for j in range(9, 1, -1): for i in range(1, 20): if i == j: print(&quot;*&quot;, end=&quot;&quot;) # 为什么判断是20-j，因为当i==j的时候，打印的*是这行打印的第一个*，每行长度是20，最后一个*的位置肯定在20-j的位置，为了对称。 elif i == 20 - j: print(&quot;*&quot;) break else: print(&quot; &quot;, end=&quot;&quot;) 第三部分 123456# 和打印正方形的原理是一样，判断哪个位置打印*，这里不同，为了好看，要灵活判断打印*的位置，这里i是奇数的时候打印*，是偶数时候是打印*空格for i in range(1, 20): if i % 2 != 0: print(&quot;*&quot;, end=&quot;&quot;) else: print(&quot; &quot;, end=&quot;&quot;)]]></content>
  </entry>
</search>
